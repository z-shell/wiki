#!/usr/bin/env node

/**
 * Barrel File Documentation Generator
 *
 * This script analyzes the component barrel file and generates documentation
 * about which components are exported and their categories.
 *
 * Usage:
 *   node scripts/document-barrel.js
 */

/* trunk-ignore(eslint/@typescript-eslint/no-require-imports) */
const fs = require("fs");
/* trunk-ignore(eslint/@typescript-eslint/no-require-imports) */
const path = require("path");

// Paths
const COMPONENTS_DIR = path.join(__dirname, "..", "src", "components");
const BARREL_FILE = path.join(COMPONENTS_DIR, "index.ts");
const OUTPUT_FILE = path.join(__dirname, "..", ".github", "barrel-exports.md");
const OLD_OUTPUT_FILE = path.join(__dirname, "..", "barrel-exports.md");

// Read the barrel file
const barrelContent = fs.readFileSync(BARREL_FILE, "utf8");

// Parse the barrel file for sections and exports
const sections = [];
let currentSection = null;

barrelContent.split("\n").forEach((line) => {
  // Check for section headers (comments with ===== or similar)
  const sectionMatch = line.match(/\/\/\s*=+\s*([^=]+)\s*=+/);
  if (sectionMatch) {
    currentSection = {
      name: sectionMatch[1].trim(),
      exports: [],
    };
    sections.push(currentSection);
    return;
  }

  // Check for exports
  const exportMatch = line.match(/export\s*{\s*(?:default\s+as\s+)?([^}]+)}/);
  if (exportMatch && currentSection) {
    const exports = exportMatch[1].split(",").map((e) => {
      // Handle "default as Component" or just "Component"
      const nameParts = e.trim().split(/\s+as\s+/);
      return nameParts.length > 1 ? nameParts[1] : nameParts[0];
    });
    currentSection.exports.push(...exports);
  }
});

// Generate markdown documentation
let markdown = `# Z-Shell Wiki Component Exports\n\n`;
markdown += `This document provides an overview of all components exported from the barrel file (\`src/components/index.ts\`).\n\n`;
markdown += `This file is automatically generated by the \`scripts/document-barrel.js\` script. Do not edit it directly.\n\n`;
markdown += `Last updated: ${new Date().toISOString().split("T")[0]}\n\n`;

markdown += `## Usage\n\n`;
markdown += `Components can be imported from the barrel file in two ways:\n\n`;
markdown += `### For regular components (non-MDX):\n\n`;
markdown += `\`\`\`tsx\n`;
markdown += `import { ComponentName } from '@site/src/components';\n\n`;
markdown += `function MyComponent() {\n`;
markdown += `  return <ComponentName />;\n`;
markdown += `}\n`;
markdown += `\`\`\`\n\n`;
markdown += `### For MDXComponents.tsx (some components may need direct imports):\n\n`;
markdown += `\`\`\`tsx\n`;
markdown += `// Via barrel file (most components)\n`;
markdown += `import { ComponentA, ComponentB } from '@site/src/components';\n\n`;
markdown += `// Direct imports (for components with path resolution issues)\n`;
markdown += `import ComponentC from '../components/ComponentC';\n`;
markdown += `\`\`\`\n\n`;

markdown += `## Component Categories\n\n`;
markdown += `The Z-Shell Wiki components are organized into the following categories:\n\n`;
sections.forEach((section) => {
  markdown += `- **${section.name}**: ${section.exports.length} components\n`;
});
markdown += `\n`;

sections.forEach((section) => {
  markdown += `## ${section.name}\n\n`;

  if (section.exports.length === 0) {
    markdown += `*No components in this section*\n\n`;
    return;
  }

  markdown += `| Component | File Path |\n`;
  markdown += `|-----------|----------|\n`;

  section.exports.forEach((componentName) => {
    // Clean up component name (remove any extra characters)
    const cleanName = componentName.trim();

    // Try to determine the file path (simple heuristic)
    let filePath = `src/components/${cleanName}/index.tsx`;

    // For non-default exports like Note, Tip, Warning from Callouts
    if (cleanName === "Note" || cleanName === "Tip" || cleanName === "Warning") {
      filePath = "src/components/Callouts/index.tsx";
    } else if (cleanName === "TabItem") {
      filePath = "src/components/CodeTabs/index.tsx";
    } else if (cleanName === "HeroBanner") {
      filePath = "src/components/HomeBanner/index.tsx";
    }

    markdown += `| \`${cleanName}\` | \`${filePath}\` |\n`;
  });

  markdown += `\n`;
});

// Ensure .github directory exists
const githubDir = path.join(__dirname, "..", ".github");
if (!fs.existsSync(githubDir)) {
  fs.mkdirSync(githubDir, {recursive: true});
}

// Write the documentation
fs.writeFileSync(OUTPUT_FILE, markdown);
console.log(`Documentation written to ${OUTPUT_FILE}`);

// Remove old file if it exists
if (fs.existsSync(OLD_OUTPUT_FILE)) {
  fs.unlinkSync(OLD_OUTPUT_FILE);
  console.log(`Removed old file: ${OLD_OUTPUT_FILE}`);
}
